<!--
imported-template.html v0.0.1
(c) 2013 Joachim Wester
MIT license
https://github.com/PuppetJs/imported-template
-->
<link rel="import" href="../polymer/polymer.html">
<script>
  (function () {
    var XHTMLPrototype = Object.create( (HTMLTemplateElement || HTMLElement ).prototype);

    XHTMLPrototype.loadTemplate_ = function() {
      var val = this.getAttribute('content');
      var asIframe = this.getAttribute("iframe") || this.getAttribute("iframe")==="";
      var xhtml = this;
      if (val && (val.indexOf('/') === 0 || val.indexOf('./') === 0)) {
        if( asIframe ){
           this.loadIframe(val);
           return;
        }
        // TODO: clean it, rearange it (tomalec)

        //val is a URL, load the partial from the HTTP server/cache
        var link = document.createElement('link');
        link.rel = "import";
        link.href = val;
        link.onload =  function processImportedDocument(){
          // TODO: clear previous template (tomalec)
          var template = this.import.querySelector("template");
          // simple template
          if(!template){
            template = this.import.createElement("template");
            template.setAttribute("bind","");
            // move entire content to tempalte
            // TODO: check if moving by text is faster, 
            //      as we assume it is simple template => we can use it as static HTML (tomalec)
            while( this.import.body.firstChild ){
              template.content.appendChild(this.import.body.firstChild);
            }
            this.import.body.appendChild(template);

          }

          // var clone = document.importNode(template.content, true);
          var clone = document.importNode(template, true);
          if(window.PolymerExpressions) {
            clone.bindingDelegate = new PolymerExpressions; //use PolymerExpressions if available. This allows <template if="{{val == 1}}">, etc
          }
          clone.model = xhtml.model;
          xhtml.parentNode.insertBefore(clone, xhtml.nextSibling);

        };
        document.head.appendChild(link);

      }
      else {
        if( asIframe ){
          this.loadIframe(undefined, encodeURI(val)
            );
        } else {
          //val is HTML code, insert the partial from the string
          this.reattachTemplate_(val);
        }
      }
    };
    XHTMLPrototype.loadIframe = function(src, srcdoc){
      var iframe = document.createElement('iframe');
      iframe.src = src;
      srcdoc && (iframe.srcdoc = srcdoc);
      this.parentNode.insertBefore(iframe, this.nextSibling);
      // TODO: keep a reference to be able to remove/update it later (tomalec)
    };

    XHTMLPrototype.reattachTemplate_ = function(html) {
      if( this.subTemplate ){
        // IDEA: or maybe just this.subTempalte.clear()? - to leave lightDOM template untouched (tomalec)
        this.clear();
      } else {
        this.subTemplate = document.createElement("template");
      }
      this.subTemplate.setAttribute("bind","");
      this.subTemplate.innerHTML = html;
      this.parentNode.insertBefore(this.subTemplate, this.nextSibling);
      // TODO: do we need this? (tomalec)
      if(window.PolymerExpressions) {
        this.subTemplate.bindingDelegate = new PolymerExpressions; //use PolymerExpressions if available. This allows <template if="{{val == 1}}">, etc
      }
      this.subTemplate.model = this.model;

    };

    /**
     * Empty xhml content.
     * @requires HTMLTemplateElement#clear (https://github.com/Polymer/TemplateBinding/blob/51df59c16e0922dec041cfe604016aac00918d5d/src/TemplateBinding.js#L595)
     * @extends HTMLTemplateElement.prototype.clear
     * @return  see HTMLTemplateElement.prototype.clear
     */
    XHTMLPrototype.clear = function(){
      return this.subTemplate.clear() && HTMLTemplateElement.prototype.clear.call(this);
    }


    XHTMLPrototype.attachedCallback = function () {
      var that = this;
      this.loadTemplate_();

      var observer = new MutationObserver(function (mutations) {
        mutations.forEach(function (mutation) {
          if (mutation.type === "attributes" && mutation.attributeName === "content") {
            that.loadTemplate_();
          }
        });
      });
      observer.observe(this, {
        attributes: true
      });
    };

    document.register('imported-template', {
      prototype: XHTMLPrototype,
      extends: "template"
    });


   
  })();
</script>